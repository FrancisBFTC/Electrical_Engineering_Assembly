MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ; **************************************************************************************************
                      00002 ; Prova N.2 - Questão 1 e 2
                      00003 ; Assembly Microcontrolador PIC12F675
                      00004 ;
                      00005 ; Curso   : Eng. Elétrica da IFBA 
                      00006 ; Autora  : Dirlene Napoleão   Data: 19/11/2021
                      00007 ; Clock   : 4MHz (Oscilação interna)  Arquivo : Sistema_Amostragem.asm 
                      00008 ; Programa: Classificação de sinais analógicos e calculo da Área de onda 
                      00009 ;
                      00010 ; O QUE ESTE PROGRAMA FAZ?
                      00011 ; 
                      00012 ; No inicio, ele configura o registrador de Interrupção por Overflow do TMR0
                      00013 ; TMR0 Prescaler, configura o pino 0 para entrada analogica e habilita o
                      00014 ; conversor A/D. Após isto, o programa contabiliza 20ms através de WaitDeltaT,
                      00015 ; ocorre uma interrupção e completa o resto de tempo dentro da ISR.
                      00016 ; Na ISR espera pela Conversão do sinal analogico e apos receber o dado de 10 bits, 
                      00017 ; uma decodificação é feita para garantir o valor decimal igual ao que foi coletado.
                      00018 ; Verifica a ordem do sinal pra armazenar o valor no respectivo registro e depois efetua
                      00019 ; a soma deste valor com o valor anterior, isto é feito até 10 sinais coletados a cada 20ms.
                      00020 ; A partir do 10ª sinal, uma multiplicação é feita por DeltaT e o valor da Área abaixo  
                      00021 ; da forma de onda é concedido (Aproximação de partição regular). As 10 categorias de sinais
                      00022 ; são coletadas no período de 200ms. Bônus: 3 destes sinais são comparados para ligar 3 LEDs.
                      00023 ;
                      00024 ; CONSIDERAÇÕES IMPORTANTES:
                      00025 ;
                      00026 ; 1. Dentro da pasta da Prova existe um arquivo chamado "ProvaN2_INFO.txt" que eu
                      00027 ; mostro as configurações manuais do Pwlin, as configurações dos registros, os
                      00028 ; sinais analógicos estudados correspondentes ao ADRESH e ADRESL, a explicação
                      00029 ; do cálculo da área e definições de variáveis da Questão 2 e a lógica do porque
                      00030 ; deu o valor concedido da Área.
                      00031 ; 2. No arquivo "libprog.inc", adicionada ao projeto eu configurei a palavra
                      00032 ; de configuração, Criei definições dos pinos, Criei as macros de seleção de
                      00033 ; Banco e macros para armazenamento do contexto na interrupção, Criei as 21
                      00034 ; GPRs para este programa e também fiz uma explicação de cada GPR no inicio da lib
                      00035 ; com seus respectivos endereços e também expliquei a lógica do cálculo da Área. 
                      00036 ; **************************************************************************************************
                      00037 
Warning[205]: Found directive in column 1. (list)
Warning[215]: Processor superseded by command line.  Verify processor symbol.
                      00038 list p=12F675                                                           ; Microcontrolador a ser utiliza
                            do
                      00039 
                      00040 #include <p12f675.inc>                                          ; Arquivo de inclusão do Microcontrolado
                            r
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ;  MPASM PIC12F675 processor include
                      00005 ; 
                      00006 ;  (c) Copyright 1999-2013 Microchip Technology, All rights reserved
                      00007 ;==========================================================================
                      00008 
Message[301]: MESSAGE: (Processor-header file mismatch.  Verify selected processor.)
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00366         LIST
                      00041 #include <libprog.inc>                                          ; Configuração,Definições de pinos, macr
                            os e variáveis
                      00001 ; **************************************************************************************************
                      00002 ; Prova N.2 - Questão 1 e 2 (Arquivo de Inclusão)
                      00003 ; Assembly Microcontrolador PIC12F675
                      00004 ;
                      00005 ; Curso   : Eng. Elétrica da IFBA 
                      00006 ; Autora  : Dirlene Napoleão   Data: 19/11/2021
                      00007 ; Clock   : 4MHz (Oscilação interna)  Arquivo: libprog.inc 
                      00008 ; Programa: Classificação de sinais analógicos e calculo da Área de onda 
                      00009 ;
                      00010 ; REGISTROS DE PROPÓSITOS GERAIS & ENDEREÇOS
                      00011 ;
                      00012 ; W_TEMP (0x40) -> Pra Armazenar contexto de W antes da interrupção 
                      00013 ; STATUS_TEMP (0x41) -> Pra Armazenar contexto de STATUS antes da interrupção
                      00014 ; DEC1 (0x42)   -> 1ª Registro auxiliar para decodificação de ADRESH:ADRESL
                      00015 ; DEC2 (0x43)   -> 2ª Registro auxiliar para decodificação de ADRESH:ADRESL
                      00016 ; V_TEMP (0x44) -> Armazena o dado analogico decodificado de cada sinal
                      00017 ; CONT (0x45)   -> Contador auxiliar para resto de tempo 20ms
                      00018 ; QNT  (0x46)   -> Ordem do sinal atual/Quantidade de sinais coletados
                      00019 ; _V1..._V10 (0x47...0x50) -> Pra armazenar cada sinal coletado, são 10 sinais
                      00020 ; _RkArea (0x51) -> Armazena cada sinal somado com o anterior
                      00021 ; _AreaH  (0x52) -> Parte Alta do resultado da multiplicação da Área
                      00022 ; _AreaL  (0x53) -> Parte Baixa do resultado da multiplicação da Área
                      00023 ; _DeltaT (0x54) -> Armazena o valor de 20ms / 10.
                      00024 ; ENDP    (0x55) -> Registro que sinaliza fim do programa
                      00025 
                      00026 ; ROTINAS INICIAIS DO PROGRAMA
                      00027 ;
                      00028 ; _Start     -> Configura as SFRs para Conversão A/D e Interrupção
                      00029 ; WaitDeltaT -> Espera tempo de "quase" 20ms pra cada coleta (Resto de tempo é completado na ISR)
                      00030 ;
                      00031 ; ROTINAS DA ISR DO PROGRAMA
                      00032 ;
                      00033 ;  _StartINT  -> Inicio da Interrupção que armazena contextos, preenche os 20ms e reconfigura TMR0
                      00034 ; Conversion  -> Seta BIT 'GO_DONE' de 'ADCON0' para iniciar conversão A/D
                      00035 ; WaitConv    -> Loop que espera pela conversão A/D ser finalizada
                      00036 ; Decoding    -> Decodifica dados em ADRESH:ADRESL mesclando em 8 bits e dividindo por 2
                      00037 ; VerifyOrder -> Incrementa QNT e identifica ordem do sinal, armazena o sinal de acordo com a ordem
                      00038 ; ADD_V1..._V10 -> Armazena cada dado analógico coletado nos seus respectivos registros e vai pra soma
                      00039 ; AreaAdd     -> Soma do sinal coletado com o sinal anterior, armazenando em _RkArea
                      00040 ; MulDeltaT   -> Prepara os registros para a multiplicação da Área
                      00041 ; MUL -> Multiplica o valor total da soma em _AreaL por _DeltaT (20 / 10), resultado em _AreaH:_AreaL
                      00042 ; CompareSignal -> Compara 3 sinais elétricos, dependendo do sinal a rotina liga um dos LEDs
                      00043 ; ON_LED1     -> Aciona o LED 1 entre 0.03V e 0.05V
                      00044 ; ON_LED2         -> Aciona o LED 2 e Desaciona o LED 1 entre 0.13V e 0.21v
                      00045 ; ON_LED3         -> Aciona o LED 3 e Desaciona o LED 2 entre 0.55V e 0.89V
                      00046 ;
                      00047 ; EXPLICAÇÕES DA LÓGICA DO RESULTADO DA ÁREA 
                      00048 ;
                      00049 ; A cada 20ms exatos um sinal analógico é coletado da fonte Pwlin (Pwlin já pré-configurado 
                      00050 ; manualmente) e no período total de 200ms, as 10 categorias (10 sinais) foram coletadas, 
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00051 ; cada sinal com sua representação digital e decimal no seu respectivo registrador. 
                      00052 ; Somei todos os sinais e armazenei num outro registrador e depois multipliquei por (20 / 10)
                      00053 ; que deu 462. 462 é a área abaixo da curva de onda, onda que pode variar entre 0 a 5V, 
                      00054 ; ou seja, a área é 4,62V. Porém se pegássemos 0.90V / 2 = 0.45V que é ~= 0.46V Logo 0,462V 
                      00055 ; (ou 462mV) seria a aproximação regular abaixo da forma de onda de 0.01V até 0.9V... 
                      00056 ;
                      00057 ; Um pouco abaixo da metade de 1.0V, 10 vezes, seria o mesmo que dizer 4,62V
                      00058 ; abaixo de uma onda que varia até 5V, se falamos da metade de 1.0V, logo:
                      00059 ;
                      00060 ; 10 vezes / 2 = 5V, ou seja, 10 vezes de aproximações regulares de 1V.
                      00061 ;
                      00062 ; T
                      00063 ; r(t) ~= {k=0 a N}rK x dT
                      00064 ; 0
                      00065 ;
                      00066 ; N = 10
                      00067 ; r = sinal
                      00068 ; k = instante de tempo
                      00069 ; rK = sinal somado
                      00070 ; T = 200ms
                      00071 ; t = 20ms
                      00072 ; r(t) = sinal atual
                      00073 ; _DeltaT (dT) = 20 (20 / 10)
                      00074 ; _RkArea (rK) = 231 (2,31) -> de 0ms a N somas
                      00075 ; _Area = _RkArea x DeltaT
                      00076 ; _Area = 231 x 2 = 462 | 2,31V x 200 = 462
                      00077 ;
                      00078 ; de 0 a 200ms, r(t) ~= 4,62V | 0V < r(t) < 5V
                      00079 ; 0.90V / (20ms / 10) = 0,45V ~= 0,46V
                      00080 ;
                      00081 ; r(t) ~= 0,500V <-> r(t) = 1V
                      00082 ; r(t) ~= 0,462V <-> r(t) = 0.9V
                      00083 ; r(t) ~= 2,500V <-> r(t) = 5V
                      00084 ; r(t) ~= 2,310V <-> r(t) = 4,62V 
                      00085 ;
                      00086 ; Somatório: 0.01 + 0.02 + 0.03 + 0.05 + 0.08 + 0.13 + 0.21 + 0.34 + 0.55 + 0.89 = 2,31 (231)
                      00087 ; Multiplicação: (2,31 x 20 = 46,2) ou (2,31 x 200 = 462) ou (2,31 x 2 = 4,62)
                      00088 ;
                      00089 ; ÚLTIMAS CONSIDERAÇÕES
                      00090 ;
                      00091 ; Na pasta do Projeto tem a imagem "Depuracao_ProvaN2" com o Print da Tela apresentando a minha depuraçã
                            o 
                      00092 ; no Proteus. Pra enxergar melhor o comportamento do programa abra o "PIC CPU Variables" em Debug e 
                      00093 ; marque os 19 registros de DEC1 até _DeltaT como Valores Decimais, o resultado da Area estará em
                      00094 ; _AreaH:_AreaL, disso achei melhor visto em Hexadecimal no PIC CPU Variables (0x1CE).
                      00095 ; E abra "PIC CPU Data Memory" a partir do Endereço 0x50, pois fica visível o valor da Área nos Endereço
                            s
                      00096 ; 0x52 e 0x53. Já na questão do tempo, eu não tive muito sucesso em depurar o tempo no Proteus
                      00097 ; Então utilizei os recursos do MPLAB. Abrindo a janela StopWatch. Marquei um BreakPoint na linha 291
                      00098 ; na 1ª definição de TMR0 e outro BreakPoint na linha 65 na 2ª definição do TMR0 dentro da ISR.
                      00099 ; Dava um "Run" até o 1ª BreakPoint, tirava o BreakPoint e zerava os 19 ciclos do StopWatch e depois
                      00100 ; Dava outro "Run" até o 2ª BreakPoint e olhava o tempo que precisamente deu 20ms antes da conversão 
                      00101 ; e cada 20000us se inicia outra conversão, 10 sinais deu 200ms.
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00102 ; Mesmo assim, pra facilitar eu adicionei um módulo de temporização no circuito do Proteus e pode-se
                      00103 ; fazer a mesma forma de depuração analisando o tempo neste módulo.
                      00104 ; **************************************************************************************************
                      00105 
                      00106 
                      00107 ; **** Palavra de Configuração do Microcontrolador ****
Warning[205]: Found directive in column 1. (__config)
2007   3F84           00108 __config        _INTRC_OSC_NOCLKOUT & _WDT_OFF & _PWRTE_ON & _MCLRE_OFF & _CPD_OFF & _CP_OFF & _BODEN_OF
                            F
                      00109 
                      00110 
                      00111 ; **** Entradas & Saídas de dados ****
                      00112 #define         _SIGNAL         GPIO, GP0                       ; Sinal Analógico no Pino 0
                      00113 #define         _LED1           GPIO, GP1                       ; Led 1 no pino 6
                      00114 #define         _LED2           GPIO, GP4                       ; Led 2 no pino 3
                      00115 #define         _LED3           GPIO, GP5                       ; Led 3 no pino 2
                      00116 #define         TIMER_ON        bsf GPIO, GP2           ; Inicia Módulo de temporização
                      00117 #define         TIMER_OFF       bcf GPIO, GP2           ; Pausa Módulo de temporização
                      00118 
                      00119 ; **** Registros de Propósitos Gerais ****
Warning[205]: Found directive in column 1. (CBLOCK)
                      00120 CBLOCK          H'40'                   ; Inicio da Memória de Usuário
  00000040            00121         W_TEMP                                  ; Registro W temporario para interrupcao
  00000041            00122         STATUS_TEMP                             ; Registro STATUS temporario para interrupcao           
                                            
  00000042            00123         DEC1                                ; Registro temporario 1 para decoding do sinal
  00000043            00124         DEC2                                    ; Registro temporario 2 para decoding do sinal
  00000044            00125         V_TEMP                              ; Armazena a voltagem temporaria atual
  00000045            00126         CONT                                    ; Contador auxiliar para tempo DeltaT
  00000046            00127         QNT                                     ; Quantidade de categorias de sinais avaliadas
  00000047            00128         _V1                                     ; 1ª sinal da voltagem
  00000048            00129         _V2                                             ; 2ª sinal da voltagem
  00000049            00130         _V3                                             ; 3ª sinal da voltagem
  0000004A            00131         _V4                                             ; 4ª sinal da voltagem
  0000004B            00132         _V5                                             ; 5ª sinal da voltagem
  0000004C            00133         _V6                                             ; 6ª sinal da voltagem
  0000004D            00134         _V7                                             ; 7ª sinal da voltagem
  0000004E            00135         _V8                                             ; 8ª sinal da voltagem
  0000004F            00136         _V9                                             ; 9ª sinal da voltagem
  00000050            00137         _V10                                    ; 10ª sinal da voltagem
  00000051            00138         _RkArea                                 ; Valores do somatorio da Area
  00000052            00139         _AreaH                                  ; Resultado final da Somatorio (Parte Alta)
  00000053            00140         _AreaL                                  ; Resultado final do Somatorio (Parte Baixa)
  00000054            00141         _DeltaT                                 ; Valor de DeltaT = 20ms / 10
  00000055            00142         ENDP                                    ; Status que finaliza o programa
Warning[205]: Found directive in column 1. (ENDC)
                      00143 ENDC                                            ; Fim da Memória de Usuário
                      00144 
                      00145 ; **** Macro para seleção de bancos  ****
                      00146 _BANK   macro   num                             ; Nome da Macro
                      00147         IF      num==0                                  ; Se num for 0, então...
                      00148                 bcf     STATUS,RP0              ; Seleciona banco de memória 0
                      00149         ENDIF                                           ; Se não...
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00150         IF      num==1                                  ; Se num for 1, então...
                      00151                 bsf     STATUS,RP0              ; Seleciona banco de memória 1
                      00152         ENDIF                                           ; Fim da condicional
Warning[205]: Found directive in column 1. (ENDM)
                      00153 ENDM                                                    ; Fim da Macro
                      00154 
                      00155 ; **** Macro para Armazenamento de Contextos  ****
                      00156 STORE_CONTEXT   macro    ; Nome da Macro
                      00157         movwf   W_TEMP           ; Salva o contexto de W no registro temporario
                      00158         swapf   STATUS,W     ; Faz uma troca de Nibbles de STATUS e salva em W
                      00159         _BANK 0                          ; Seleciona Banco de memoria 0
                      00160         movwf   STATUS_TEMP  ; Salva o contexto de STATUS no registro temporario
Warning[205]: Found directive in column 1. (ENDM)
                      00161 ENDM                                     ; Fim da macro
                      00162 
                      00163 ; **** Macro para Recuperação de Contextos  ****
                      00164 RESTORE_CONTEXT  macro     ; Nome da Macro
                      00165 END_INT:                                   ; Label de Fim da Interrupção
                      00166         swapf   STATUS_TEMP,W  ; Faz uma troca de Nibbles do STATUS temporario
                      00167         movwf   STATUS             ; Recupera o contexto de STATUS
                      00168         swapf   W_TEMP,F       ; Faz uma troca de Nibbles em W temporario
                      00169         swapf   W_TEMP,W       ; Recupera o contexto de W e não altera o BIT Z de STATUS
                      00170         retfie                             ; Retorno da Interrupcao
Warning[205]: Found directive in column 1. (ENDM)
                      00171 ENDM                                       ; Fim da Macro
                      00042 
                      00043 
                      00044 ; **** Vetor de RESET ****
0000                  00045         ORG     0x0000
0000   28A3           00046         goto    _Start
                      00047 
                      00048 ; **** Vetor de INTERRUPÇÃO ****
0004                  00049         ORG     0x0004
                      00050 ; Inicio da Interrupção causada por TMR0 ******************************************************
0004                  00051 _StartINT:
                      00052         STORE_CONTEXT                           ; Armazena os contextos STATUS e W
0004   00C0               M         movwf   W_TEMP           ; Salva o contexto de W no registro temporario
0005   0E03               M         swapf   STATUS,W     ; Faz uma troca de Nibbles de STATUS e salva em W
                          M         _BANK 0                          ; Seleciona Banco de memoria 0
                          M         IF      0==0                                    ; Se num for 0, então...
0006   1283               M                 bcf     STATUS,RP0              ; Seleciona banco de memória 0
                          M         ENDIF                                           ; Se não...
                          M         IF      0==1                                    ; Se num for 1, então...
                          M                 bsf     STATUS,RP0              ; Seleciona banco de memória 1
                          M         ENDIF                                           ; Fim da condicional
0007   00C1               M         movwf   STATUS_TEMP  ; Salva o contexto de STATUS no registro temporario
                      00053         
0008   1D0B           00054         btfss   INTCON,T0IF                     ; Ouve uma interrupcao de OverFlow do TIMER0?
0009   289E           00055         goto    END_INT                         ; Não! Entao saia da interrupcao
000A   110B           00056         bcf     INTCON,T0IF                     ; Sim! Então limpe a Flag setada pela interrupcao
                      00057 
Warning[207]: Found label after column 1. (Fill32)
000B                  00058         Fill32:                                         ; CONT = 6,logo 6 x 3 ciclos = 18
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

000B   0BC5           00059                 decfsz  CONT,F                  ; Complete 18 ciclos pra chegar a 19968us
000C   280B           00060                 goto    Fill32                  ; As outras instruções vão se encarregar de completar o 
                            resto
                      00061 
000D   3006           00062         movlw   D'6'                            ; Renova CONT com o valor 6, isto agora vai pra W
000E   00C5           00063         movwf   CONT                            ; CONT = 6. Isto e preciso pra calcular o resto de tempo
                             de 32 ciclos
000F   3064           00064         movlw   D'100'                          ; 256 - 100 = 156 Contagens
0010   0081           00065         movwf   TMR0                            ; 156 x 128 x 1us = 19968us (faltando 32 para 20ms)
                      00066                                                                 ; Do 1ª TMR0 até este TMR0 deu 20000 cic
                            los
                      00067 
                      00068 ; Começe a conversão do sinal analogico r(t) ----------------------------------------------
0011                  00069 Conversion:
0011   149F           00070         bsf     ADCON0,GO_DONE          ; Diga que estar em processo de conversão
0012                  00071 WaitConv:                                               ; Inicie o Loop de conversao
0012   189F           00072         btfsc   ADCON0, GO_DONE         ; Conversão finalizou? (BIT<1> = 0?)
0013   2812           00073         goto    WaitConv                        ; Não! Então, Espera conversão.
                      00074                                                                 ; Sim! Então comece a decodificacao do s
                            inal
                      00075 
                      00076 ; O dado analogico esta em ADRESH:ADRESL
                      00077 ; ------------------------------------------------------------------------------------------
                      00078 
                      00079 ; Decodificacao do sinal -------------------------------------------------------------------
                      00080 ; Consiste em pegar o valor de 10 bits de ADRESH:ADRESL e mescla-lo em 1
                      00081 ; so registrador de 8 bits, apos isto é dividido por 2 para saber a representacao
                      00082 ; decimal coerente ao sinal analogico
0014                  00083 Decoding:
0014   081E           00084         movf    ADRESH,W                        ; Enviamos os 8 bits de ADRESH para W
0015   00C2           00085         movwf   DEC1                            ; Movemos o conteudo de W pra um registro temporario
0016   1003           00086         bcf     STATUS,C                        ; Limpe a Carry Flag de STATUS pra não atrapalhar na rot
                            ação
0017   0DC2           00087         rlf     DEC1,F                          ; Deslocamos todos os bits para esquerda 1 vez de ADRESH
0018   1003           00088         bcf     STATUS,C                        ; Limpe novamente a Carry Flag de STATUS
0019   0DC2           00089         rlf     DEC1,F                          ; Deslocamos novamente todos os bits para esquerda de AD
                            RESH
                      00090         _BANK 1                                         ; Selecione o Banco 1, pois ADRESL é do Banco 1
                          M         IF      1==0                                    ; Se num for 0, então...
                          M                 bcf     STATUS,RP0              ; Seleciona banco de memória 0
                          M         ENDIF                                           ; Se não...
                          M         IF      1==1                                    ; Se num for 1, então...
001A   1683               M                 bsf     STATUS,RP0              ; Seleciona banco de memória 1
                          M         ENDIF                                           ; Fim da condicional
Message[302]: Register in operand not in bank 0.  Ensure that bank bits are correct.
001B   081E           00091         movf    ADRESL,W                        ; Enviamos os 2 bits de ADRESL para W (os 6 bits menos s
                            ignificativo nao sao usados)
                      00092         _BANK 0                                         ; Volte ao Banco 0 novamente
                          M         IF      0==0                                    ; Se num for 0, então...
001C   1283               M                 bcf     STATUS,RP0              ; Seleciona banco de memória 0
                          M         ENDIF                                           ; Se não...
                          M         IF      0==1                                    ; Se num for 1, então...
                          M                 bsf     STATUS,RP0              ; Seleciona banco de memória 1
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M         ENDIF                                           ; Fim da condicional
001D   00C3           00093         movwf   DEC2                            ; Recupere o conteudo de ADRESL em W para DEC2
001E   0DC3           00094         rlf     DEC2,F                          ; Desloque 1 bit para a esquerda só pra gerar a Carry Fl
                            ag (Agora precisamos dela)
001F   0DC3           00095         rlf     DEC2,F                          ; Desloque 1 bit para a esquerda
0020   0DC3           00096         rlf     DEC2,F                          ; Desloque +1 bit para a esquerda. Pronto! Enviamos o AD
                            RESL pro LSBs
0021   0842           00097         movf    DEC1,W                          ; Salvamos DEC1 em W pois abaixo vamos mesclar isto.
0022   0643           00098         xorwf   DEC2,W                          ; Mescle DEC1 e DEC2, salve em W
0023   00C4           00099         movwf   V_TEMP                          ; Movemos o dado analogico para o registro temporario da
                             Voltagem.
0024   1003           00100         bcf     STATUS,C                        ; Limpe a Carry Flag pra nao nos atrapalhar
0025   0CC4           00101         rrf     V_TEMP,F                        ; rotacione 1 bit pra direita, ou, V_TEMP / 2; Permite v
                            er o sinal coerente
                      00102 
                      00103 ; Pronto! A partir daqui V_TEMP esta com o sinal analogico decodificado!
                      00104 ; ou seja, o que era ADRESH:ADRESL, agora esta dentro de 8 bits
                      00105 ; ------------------------------------------------------------------------------------------
                      00106 
                      00107 ; Armazenamento dos sinais analogicos ------------------------------------------------------
                      00108 ; Aqui sera armazenado cada sinal entregue do Pwlin para o modulo ADC
                      00109 ; Nos seus respectivos registros, Ex.: _V1, _V2, _V3, etc... E depois fara a soma
                      00110 ; 1ª Etapa -> Verificar qual e a ordem análoga ao sinal
0026                  00111 VerifyOrder:
0026   0AC6           00112         incf    QNT,F                           ; Incremente +1 para verificar qual e o sinal
0027   0846           00113         movf    QNT,W                           ; Agora armazene em W
                      00114 
0028   3A01           00115         xorlw   D'1'                            ; Compara QNT com 1
0029   1903           00116         btfsc   STATUS,Z                        ; É igual?
002A   2850           00117         goto    Add_V1                          ; Sim, entao armazena o sinal na 1ª variavel
002B   0846           00118         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
002C   3A02           00119         xorlw   D'2'                            ; Compara QNT com 2
002D   1903           00120         btfsc   STATUS,Z                        ; É igual?
002E   2853           00121         goto    Add_V2                          ; Sim, entao armazena o sinal na 2ª variavel
002F   0846           00122         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
0030   3A03           00123         xorlw   D'3'                            ; Compara QNT com 3
0031   1903           00124         btfsc   STATUS,Z                        ; É igual?
0032   2856           00125         goto    Add_V3                          ; Sim, entao armazena o sinal na 3ª variavel
0033   0846           00126         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
0034   3A04           00127         xorlw   D'4'                            ; Compara QNT com 4
0035   1903           00128         btfsc   STATUS,Z                        ; É igual?
0036   2859           00129         goto    Add_V4                          ; Sim, entao armazena o sinal na 4ª variavel
0037   0846           00130         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
0038   3A05           00131         xorlw   D'5'                            ; Compara QNT com 5
0039   1903           00132         btfsc   STATUS,Z                        ; É igual?
003A   285C           00133         goto    Add_V5                          ; Sim, entao armazena o sinal na 5ª variavel
003B   0846           00134         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
003C   3A06           00135         xorlw   D'6'                            ; Compara QNT com 6
003D   1903           00136         btfsc   STATUS,Z                        ; É igual?
003E   285F           00137         goto    Add_V6                          ; Sim, entao armazena o sinal na 6ª variavel
003F   0846           00138         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
0040   3A07           00139         xorlw   D'7'                            ; Compara QNT com 7
0041   1903           00140         btfsc   STATUS,Z                        ; É igual?
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0042   2862           00141         goto    Add_V7                          ; Sim, entao armazena o sinal na 7ª variavel
0043   0846           00142         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
0044   3A08           00143         xorlw   D'8'                            ; Compara QNT com 8
0045   1903           00144         btfsc   STATUS,Z                        ; É igual?
0046   2865           00145         goto    Add_V8                          ; Sim, entao armazena o sinal na 8ª variavel
0047   0846           00146         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
0048   3A09           00147         xorlw   D'9'                            ; Compara QNT com 9
0049   1903           00148         btfsc   STATUS,Z                        ; É igual?
004A   286A           00149         goto    Add_V9                          ; Sim, entao armazena o sinal na 9ª variavel
004B   0846           00150         movf    QNT,W                           ; Nao! Salve o valor em W e compare a proxima categoria
004C   3A0A           00151         xorlw   D'10'                           ; Compara QNT com 10
004D   1903           00152         btfsc   STATUS,Z                        ; É igual?
004E   2870           00153         goto    Add_V10                         ; Sim, entao armazena o sinal na 10ª variavel
004F   289E           00154         goto    END_INT                         ; Nao! Saia da interrupcao (Aqui nunca sera alcançado)
                      00155 
                      00156 ; 2ª Etapa -> Armazenar o sinal decodificado no seu respectivo registro.
                      00157 ; Obs.: Lembrando que o sinal analogico atual decodificado esta em V_TEMP
                      00158 
0050                  00159 Add_V1:
0050   0844           00160         movf    V_TEMP,W                        ; Mova o sinal analogico para W
0051   00C7           00161         movwf   _V1                                     ; Salve o sinal de W para _V1
0052   2877           00162         goto    AreaAdd                         ; Pule para o somatorio da Area
0053                  00163 Add_V2:
0053   0844           00164         movf    V_TEMP,W                        ; Mova o sinal analogico para W
0054   00C8           00165         movwf   _V2                                     ; Salve o sinal de W para _V2
0055   2877           00166         goto    AreaAdd                         ; Pule para o somatorio da Area
0056                  00167 Add_V3:
0056   0844           00168         movf    V_TEMP,W                        ; Mova o sinal analogico para W
0057   00C9           00169         movwf   _V3                                     ; Salve o sinal de W para _V3
0058   2877           00170         goto    AreaAdd                         ; Pule para o somatorio da Area
0059                  00171 Add_V4:
0059   0844           00172         movf    V_TEMP,W                        ; Mova o sinal analogico para W
005A   00CA           00173         movwf   _V4                                     ; Salve o sinal de W para _V4
005B   2877           00174         goto    AreaAdd                         ; Pule para o somatorio da Area
005C                  00175 Add_V5:
005C   0844           00176         movf    V_TEMP,W                        ; Mova o sinal analogico para W
005D   00CB           00177         movwf   _V5                                     ; Salve o sinal de W para _V5
005E   2877           00178         goto    AreaAdd                         ; Pule para o somatorio da Area
005F                  00179 Add_V6:
005F   0844           00180         movf    V_TEMP,W                        ; Mova o sinal analogico para W
0060   00CC           00181         movwf   _V6                                     ; Salve o sinal de W para _V6
0061   2877           00182         goto    AreaAdd                         ; Pule para o somatorio da Area
0062                  00183 Add_V7:
0062   0844           00184         movf    V_TEMP,W                        ; Mova o sinal analogico para W
0063   00CD           00185         movwf   _V7                                     ; Salve o sinal de W para _V7
0064   2877           00186         goto    AreaAdd                         ; Pule para o somatorio da Area
0065                  00187 Add_V8
0065   0844           00188         movf    V_TEMP,W                        ; Mova o sinal analogico para W
0066   00CE           00189         movwf   _V8                                     ; Salve o sinal de W para _V8
0067   03CE           00190         decf    _V8,F                           ; Decremente -1 para atribuir o valor correto
0068   084E           00191         movf    _V8,W                           ; Guarda o resultado em W para o somatorio
0069   2877           00192         goto    AreaAdd                         ; Pule para o somatorio da Area
006A                  00193 Add_V9:
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

006A   0844           00194         movf    V_TEMP,W                        ; Mova o sinal analogico para W
006B   00CF           00195         movwf   _V9                                     ; Salve o sinal de W para _V9
006C   03CF           00196         decf    _V9,F                           ; Decremente -1 para atribuir o valor correto
006D   084F           00197         movf    _V9,W                           ; Guarda o resultado em W para o somatorio
006E   00C4           00198         movwf   V_TEMP                          ; Mova novamente pra V_TEMP para comparação posterior
006F   2877           00199         goto    AreaAdd                         ; Pule para o somatorio da Area
0070                  00200 Add_V10:
0070   0844           00201         movf    V_TEMP,W                        ; Mova o sinal analogico para W
0071   00D0           00202         movwf   _V10                            ; Salve o sinal de W para _V10
0072   03D0           00203         decf    _V10,F                          ; Decremente -1
0073   03D0           00204         decf    _V10,F                          ; Decremente -1, ou seja -2 para atribuir o valor corret
                            o
0074   0850           00205         movf    _V10,W                          ; Guarda o resultado em W para o somatorio
0075   07D1           00206         addwf   _RkArea,F                       ; Some + o ultimo sinal analogico
0076   2879           00207         goto    MulDeltaT                       ; Salte para a multiplicacao por DeltaT (Um Breakpoint a
                            qui dá 200ms)
                      00208 
                      00209 ; Obs.: Este programa pode ser facilmente adaptado pra analisar o sinal reverso (Onda decrescente)
                      00210 ; Para isto Apena zere os registros da area, decremente o registro QNT se outro registro auxiliar
                      00211 ; for 1, sendo 0 QNT incrementa, QNT sendo 10 ou 0, faz um COMF no registro auxiliar e claro:
                      00212 ; Adicionar mais voltagens nas configurações manuais do Pwlin
                      00213 ; ------------------------------------------------------------------------------------------
                      00214 
                      00215 
                      00216 ; Somatorio da Area de cada valor analogico atual ------------------------------------------
                      00217 ; 3ª Etapa -> Fazer a soma de cada sinal analogico atual com o anterior armazenando em _RkArea
0077                  00218 AreaAdd:
0077   07D1           00219         addwf   _RkArea,F                       ; Some o sinal atual com o resultado anterior e armazene
                             em RkArea
0078   2889           00220         goto    CompareSignal           ; Comparar sinais analógicos
                      00221 ; ------------------------------------------------------------------------------------------
                      00222  
                      00223         
                      00224 ; Multiplicacao das somas por DeltaT -------------------------------------------------------
                      00225 ; 4ª Etapa -> Faz a multiplicacao por DeltaT e isso so executa no 10ª sinal entregue.
                      00226 ; _RkArea  -> Registro que soma de volts em volts
                      00227 ; _AreaL   -> Armazena todas as somas dos volts (Que tambem estara em _RkArea)
                      00228 ; _AreaH   -> Parte Alta do resultado final da multiplicacao da Area
                      00229 ; _DeltaT  -> Uma faixa de tempo de cada sinal / 10 | 20ms / 10 = 2
                      00230 ; DESCRICAO IMPORTANTE :
                      00231 ;       Multiplicar 231 x 2 (462), é o mesmo que dizer: 2,31V x 200ms (462 ou 4,62V)
                      00232 ;       ou seja, tudo representa a voltagem 4,62V. Isto porque eu fiz o mapeamento usando
                      00233 ;       10 bits do registrador ADRESH:ADRESL.
                      00234 ;       462 / 10 / 10 será 4,62 logo também dividimos o tempo de 200ms / 10 / 10
                      00235 ;       que será 2, ou poderíamos dizer que, 20ms / 10 é 2 devido a 0,462 x 10 é 4,62.
                      00236 ;       Peço-lhes que leia a descrição nas primeiras linhas desse código.
0079                  00237 MulDeltaT:
0079   3001           00238         movlw   D'1'                    ; Status para finalizar o programa
007A   00D5           00239         movwf   ENDP                    ; Mova para ENDP o valor de 1
007B   01D3           00240         clrf    _AreaL                  ; Limpe o registro da parte baixa da Area
007C   01D2           00241         clrf    _AreaH                  ; Limpe o registro da parte alta da Area
007D   01D4           00242         clrf    _DeltaT                 ; Limpe o registro _DeltaT
007E   3002           00243         movlw   D'2'                    ; 20ms / 10 = 2 
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

007F   00D4           00244         movwf   _DeltaT                 ; DeltaT = 2
0080   0851           00245         movf    _RkArea,W               ; Mova para o W o valor de todas as somas
0081   00D3           00246         movwf   _AreaL                  ; Guarde na parte baixa da Area o valor de todas as somas
                      00247                 
0082                  00248 MUL:
0082   03D4           00249         decf    _DeltaT,F               ; Decremente o conteudo de _DeltaT
0083   1903           00250         btfsc   STATUS,Z                ; O Decremento Chegou a zero?
0084   289E           00251         goto    END_INT                 ; Sim! Então fim da interrupcao
0085   07D3           00252         addwf   _AreaL,F                ; Nao! Então adicione o resultado do somatorio por ela mesma
0086   1803           00253         btfsc   STATUS,C                ; Testa se Flag 'Carry' é 1, Sim? então houve transbordo...
0087   0AD2           00254         incf    _AreaH,F                ; Logo, entao incremente +1 na parte alta da Area
0088   2882           00255         goto    MUL                             ; Mas se não, Volte para MUL e decremente _DeltaT +1 vez
                      00256 ; ------------------------------------------------------------------------------------------
                      00257 
                      00258 ; Comparações de sinais elétricos para acionar LEDs ----------------------------------------
                      00259 ; Compara o sinal elétrico atual com 3 valores, um dos valores vai ligar um dos LEDs
                      00260 ; Mas como o sinal é alternado em 20ms e este tempo dá lá em cima, então vai tardar
                      00261 ; mais alguns ciclos pra assim ligar o LED, isto na depuração vai dar uma ilusão
                      00262 ; de que o LED aciona perto do próximo sinal elétrico, como se fosse entre uma faixa e outra.
0089                  00263 CompareSignal:                                  ; Compara 3 sinais analógicos para ligar 3 LEDs
0089   0844           00264         movf    V_TEMP,W                        ; Move o tensão atual para W
008A   3A03           00265         xorlw   D'003'                          ; Compara tensão atual com 0,03V
008B   1903           00266         btfsc   STATUS,Z                        ; É igual a 0,03V?
008C   2896           00267         goto    ON_LED1                         ; Sim, então liga LED 1
008D   0844           00268         movf    V_TEMP,W                        ; Não, então mova a tensão atual para W
008E   3A0D           00269         xorlw   D'013'                          ; Compara tensão atual com 0,13V
008F   1903           00270         btfsc   STATUS,Z                        ; É igual a 0,13V?
0090   2898           00271         goto    ON_LED2                         ; Sim, então liga LED 2
0091   0844           00272         movf    V_TEMP,W                        ; Não, então mova a tensão atual para W
0092   3A37           00273         xorlw   D'055'                          ; Compara tensão atual com 0,55V
0093   1903           00274         btfsc   STATUS,Z                        ; É igual a 0,55V?
0094   289B           00275         goto    ON_LED3                         ; Sim, então liga LED 3
0095   289E           00276         goto    END_INT                         ; Fim da Interrupção
                      00277 
0096                  00278 ON_LED1:                                                ; Aciona entre 0.03V a 0.05V
0096   1485           00279         bsf     _LED1                           ; Desligue LED 1
0097   289E           00280         goto    END_INT                         ; Finalize interrupção
0098                  00281 ON_LED2:                                                ; Aciona entre 0.13V a 0.21V 
0098   1085           00282         bcf     _LED1                           ; Desligue LED 1
0099   1605           00283         bsf     _LED2                           ; E Ligue LED 2
009A   289E           00284         goto    END_INT                         ; Finalize interrupção
009B                  00285 ON_LED3:                                                ; Aciona entre 0.55V a 0.89V
009B   1205           00286         bcf     _LED2                           ; Desligue LED 2
009C   1685           00287         bsf     _LED3                           ; E Ligue LED 3
009D   289E           00288         goto    END_INT                         ; Finalize interrupção
                      00289 ; ------------------------------------------------------------------------------------------
                      00290 
                      00291         RESTORE_CONTEXT                 ; Restaura os contextos de STATUS e W
009E                      M END_INT:                                   ; Label de Fim da Interrupção
009E   0E41               M         swapf   STATUS_TEMP,W  ; Faz uma troca de Nibbles do STATUS temporario
009F   0083               M         movwf   STATUS             ; Recupera o contexto de STATUS
00A0   0EC0               M         swapf   W_TEMP,F       ; Faz uma troca de Nibbles em W temporario
00A1   0E40               M         swapf   W_TEMP,W       ; Recupera o contexto de W e não altera o BIT Z de STATUS
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 11


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00A2   0009               M         retfie                             ; Retorno da Interrupcao
                      00292 ; Fim da Interrupção Causada por TMR0 ***********************************************************
                      00293 
                      00294 
                      00295 
                      00296 ; Inicio do Programa e Configurações dos registradores *******************************************
00A3                  00297 _Start:
                      00298         _BANK 1
                          M         IF      1==0                                    ; Se num for 0, então...
                          M                 bcf     STATUS,RP0              ; Seleciona banco de memória 0
                          M         ENDIF                                           ; Se não...
                          M         IF      1==1                                    ; Se num for 1, então...
00A3   1683               M                 bsf     STATUS,RP0              ; Seleciona banco de memória 1
                          M         ENDIF                                           ; Fim da condicional
00A4   3086           00299         movlw   B'10000110'     ; Desabilita Pull-Ups, transição de descida  110  
Message[302]: Register in operand not in bank 0.  Ensure that bank bits are correct.
00A5   0081           00300         movwf   OPTION_REG              ; & TMR0 Prescaler = 128 ciclos por cada contagem -> H'86'
00A6   3001           00301         movlw   B'00000001'             ; Configura apenas Pino GP0 como Entrada
Message[302]: Register in operand not in bank 0.  Ensure that bank bits are correct.
00A7   0085           00302         movwf   TRISIO                  ; GP2,GP4 como saída -> H'01'   
00A8   3011           00303         movlw   B'00010001'             ; Configura <6:4> = 001 = 2us de Conversão
Message[302]: Register in operand not in bank 0.  Ensure that bank bits are correct.
00A9   009F           00304         movwf   ANSEL                   ; <3:0> = 0001 = Pino 0 como Analógico -> H'11'
                      00305 
                      00306         _BANK 0
                          M         IF      0==0                                    ; Se num for 0, então...
00AA   1283               M                 bcf     STATUS,RP0              ; Seleciona banco de memória 0
                          M         ENDIF                                           ; Se não...
                          M         IF      0==1                                    ; Se num for 1, então...
                          M                 bsf     STATUS,RP0              ; Seleciona banco de memória 1
                          M         ENDIF                                           ; Fim da condicional
                      00307 
00AB   30A0           00308         movlw   B'10100000'             ; BIT<7> = Habilita Interrupções Globais 
00AC   008B           00309         movwf   INTCON                  ; BIT<5> = Habilita interrupção por TIMER0 -> H'A0'
00AD   3007           00310         movlw   B'00000111'             ; <2:0> = 111 = Desabilita os comparadores
00AE   0099           00311         movwf   CMCON                   ; Outros bits não utilizados -> H'07'
00AF   3001           00312         movlw   B'00000001'             ; <7> = Justificado para Esquerda; <6> = VDD
00B0   009F           00313         movwf   ADCON0                  ; <3:2> = Canal AN0; <1> = Nao esta em progresso
                      00314                                                         ; <0> = Habilita Conversor A/D -> H'01'
                      00315 ;      ADRESH     :     ADRESL
                      00316 ; 0 0 0 0 0 0 0 0       0 0 x x x x x x
                      00317 ; Saída da conversão de 10 Bits
                      00318 ; Vou considerar todos os bits para decodificar o 
                      00319 ; valor e transforma-lo em 8 bits (Na rotina Decoding dentro da ISR) 
                      00320 ; *************************************************************************************************
00B1   1085           00321         bcf     _LED1                           ; Desacione LED 1
00B2   1205           00322         bcf     _LED2                           ; Desacione LED 2
00B3   1285           00323         bcf     _LED3                           ; Desacione LED 3
                      00324 
                      00325 ; Tempo de 20ms a cada sinal analogico coletado na ISR ********************************************
00B4                  00326 WaitDeltaT:
00B4   3006           00327         movlw   D'6'                            ; 6 coloca em W
00B5   00C5           00328         movwf   CONT                            ; CONT = 6. Isto e preciso pra calcular o resto de tempo
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 12


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                             de 32 ciclos
00B6   3064           00329         movlw   D'100'                          ; 256 - 100 = 156 Contagens
00B7   0081           00330         movwf   TMR0                            ; 156 x 128 x 1us = 19968us (faltando 32 para 20ms)
00B8   1505           00331         TIMER_ON                                        ; Inicia a temporização no módulo
                      00332                                                                 ; Porem, 3 ciclos a mais sao executados 
                            antes de saltar pra interrupcao
                      00333                                                                 ; logo, 19968 + 3 = 19971; 7 ciclos sao 
                            executados antes de 'Fill32' na
                      00334                                                                 ; ISR e Fill32 executa 6 x 3 ciclos = 18
                             ciclos, logo 18 + 7 = 25 ciclos.
                      00335                                                                 ; Apos Fill32 executa 4 ciclos, 25 + 4 =
                             29, 19971 + 29 = 20000 ciclos. 
                      00336                                                                 ; Se marcar um BreakPoint começando da l
                            inha 327 (1ª definicao do TMR0)
                      00337                                                                 ; E outro BreakPoint terminando na linha
                             65 (2ª definicao do TMR0 dentro da ISR)
                      00338                                                                 ; Vera que executa exatamente 20000us = 
                            20ms no MPLAB
                      00339                                 
00B9                  00340 _LOOP:
00B9   1C55           00341         btfss   ENDP,0                          ; Se BIT 0 esta definido pra 1, então salve para END
00BA   28B9           00342         goto    _LOOP                           ; Um loop pra contabilizar o tempo, alguma coisa pode se
                            r colocada aqui 
                      00343                                                                 ; Enquanto o temporizador estiver em pro
                            gresso.
                      00344 ; Após esta linha o PIC causará um Stack Underflow, se quiser continuar
                      00345 ; o programa, é só trocar o _LOOP acima por um loop infinito
                      00346 
                      00347 ; *************************************************************************************************
                      00348 
Warning[205]: Found directive in column 1. (END)
                      00349 END                                                             ; Fim do programa
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 13


SYMBOL TABLE
  LABEL                             VALUE 

ADCON0                            0000001F
ADCS0                             00000004
ADCS1                             00000005
ADCS2                             00000006
ADFM                              00000007
ADIE                              00000006
ADIF                              00000006
ADON                              00000000
ADRESH                            0000001E
ADRESL                            0000009E
ANS0                              00000000
ANS1                              00000001
ANS2                              00000002
ANS3                              00000003
ANSEL                             0000009F
Add_V1                            00000050
Add_V10                           00000070
Add_V2                            00000053
Add_V3                            00000056
Add_V4                            00000059
Add_V5                            0000005C
Add_V6                            0000005F
Add_V7                            00000062
Add_V8                            00000065
Add_V9                            0000006A
AreaAdd                           00000077
C                                 00000000
CAL0                              00000002
CAL1                              00000003
CAL2                              00000004
CAL3                              00000005
CAL4                              00000006
CAL5                              00000007
CHS0                              00000002
CHS1                              00000003
CINV                              00000004
CIS                               00000003
CM0                               00000000
CM1                               00000001
CM2                               00000002
CMCON                             00000019
CMIE                              00000003
CMIF                              00000003
CONT                              00000045
COUT                              00000006
CompareSignal                     00000089
Conversion                        00000011
DC                                00000001
DEC1                              00000042
DEC2                              00000043
Decoding                          00000014
EEADR                             0000009B
EECON1                            0000009C
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 14


SYMBOL TABLE
  LABEL                             VALUE 

EECON2                            0000009D
EEDAT                             0000009A
EEDATA                            0000009A
EEIE                              00000007
EEIF                              00000007
ENDP                              00000055
END_INT                           0000009E
F                                 00000001
FSR                               00000004
Fill32                            0000000B
GIE                               00000007
GO                                00000001
GO_DONE                           00000001
GO_NOT_DONE                       00000001
GP0                               00000000
GP1                               00000001
GP2                               00000002
GP3                               00000003
GP4                               00000004
GP5                               00000005
GPIE                              00000003
GPIF                              00000000
GPIO                              00000005
GPIO0                             00000000
GPIO1                             00000001
GPIO2                             00000002
GPIO3                             00000003
GPIO4                             00000004
GPIO5                             00000005
INDF                              00000000
INTCON                            0000000B
INTE                              00000004
INTEDG                            00000006
INTF                              00000001
IOC                               00000096
IOC0                              00000000
IOC1                              00000001
IOC2                              00000002
IOC3                              00000003
IOC4                              00000004
IOC5                              00000005
IOCB                              00000096
IOCB0                             00000000
IOCB1                             00000001
IOCB2                             00000002
IOCB3                             00000003
IOCB4                             00000004
IOCB5                             00000005
IRP                               00000007
MUL                               00000082
MulDeltaT                         00000079
NOT_BOD                           00000000
NOT_BOR                           00000000
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 15


SYMBOL TABLE
  LABEL                             VALUE 

NOT_DONE                          00000001
NOT_GPPU                          00000007
NOT_PD                            00000003
NOT_POR                           00000001
NOT_T1SYNC                        00000002
NOT_TO                            00000004
ON_LED1                           00000096
ON_LED2                           00000098
ON_LED3                           0000009B
OPTION_REG                        00000081
OSCCAL                            00000090
PCL                               00000002
PCLATH                            0000000A
PCON                              0000008E
PEIE                              00000006
PIE1                              0000008C
PIR1                              0000000C
PS0                               00000000
PS1                               00000001
PS2                               00000002
PSA                               00000003
QNT                               00000046
RD                                00000000
RESTORE_CONTEXT                   
RP0                               00000005
RP1                               00000006
STATUS                            00000003
STATUS_TEMP                       00000041
STORE_CONTEXT                     
T0CS                              00000005
T0IE                              00000005
T0IF                              00000002
T0SE                              00000004
T1CKPS0                           00000004
T1CKPS1                           00000005
T1CON                             00000010
T1IE                              00000000
T1IF                              00000000
T1OSCEN                           00000003
TIMER_OFF                         bcf GPIO, GP2
TIMER_ON                          bsf GPIO, GP2
TMR0                              00000001
TMR0IE                            00000005
TMR0IF                            00000002
TMR1                              0000000E
TMR1CS                            00000001
TMR1GE                            00000006
TMR1H                             0000000F
TMR1IE                            00000000
TMR1IF                            00000000
TMR1L                             0000000E
TMR1ON                            00000000
TRISIO                            00000085
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 16


SYMBOL TABLE
  LABEL                             VALUE 

TRISIO0                           00000000
TRISIO1                           00000001
TRISIO2                           00000002
TRISIO3                           00000003
TRISIO4                           00000004
TRISIO5                           00000005
VCFG                              00000006
VR0                               00000000
VR1                               00000001
VR2                               00000002
VR3                               00000003
VRCON                             00000099
VREN                              00000007
VRR                               00000005
V_TEMP                            00000044
VerifyOrder                       00000026
W                                 00000000
WPU                               00000095
WPU0                              00000000
WPU1                              00000001
WPU2                              00000002
WPU4                              00000004
WPU5                              00000005
WR                                00000001
WREN                              00000002
WRERR                             00000003
W_TEMP                            00000040
WaitConv                          00000012
WaitDeltaT                        000000B4
Z                                 00000002
_AreaH                            00000052
_AreaL                            00000053
_BANK                             
_BODEN_OFF                        00003FBF
_BODEN_ON                         00003FFF
_BOREN_OFF                        00003FBF
_BOREN_ON                         00003FFF
_CONFIG                           00002007
_CPD_OFF                          00003FFF
_CPD_ON                           00003EFF
_CP_OFF                           00003FFF
_CP_ON                            00003F7F
_DEVID1                           00002006
_DeltaT                           00000054
_EC_OSC                           00003FFB
_EXTRC_OSC_CLKOUT                 00003FFF
_EXTRC_OSC_NOCLKOUT               00003FFE
_FOSC_EC                          00003FFB
_FOSC_EXTRCCLK                    00003FFF
_FOSC_EXTRCIO                     00003FFE
_FOSC_HS                          00003FFA
_FOSC_INTRCCLK                    00003FFD
_FOSC_INTRCIO                     00003FFC
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 17


SYMBOL TABLE
  LABEL                             VALUE 

_FOSC_LP                          00003FF8
_FOSC_XT                          00003FF9
_HS_OSC                           00003FFA
_IDLOC0                           00002000
_IDLOC1                           00002001
_IDLOC2                           00002002
_IDLOC3                           00002003
_INTRC_OSC_CLKOUT                 00003FFD
_INTRC_OSC_NOCLKOUT               00003FFC
_LED1                             GPIO, GP1
_LED2                             GPIO, GP4
_LED3                             GPIO, GP5
_LOOP                             000000B9
_LP_OSC                           00003FF8
_MCLRE_OFF                        00003FDF
_MCLRE_ON                         00003FFF
_PWRTE_OFF                        00003FFF
_PWRTE_ON                         00003FEF
_RkArea                           00000051
_SIGNAL                           GPIO, GP0
_Start                            000000A3
_StartINT                         00000004
_V1                               00000047
_V10                              00000050
_V2                               00000048
_V3                               00000049
_V4                               0000004A
_V5                               0000004B
_V6                               0000004C
_V7                               0000004D
_V8                               0000004E
_V9                               0000004F
_WDTE_OFF                         00003FF7
_WDTE_ON                          00003FFF
_WDT_OFF                          00003FF7
_WDT_ON                           00003FFF
_XT_OSC                           00003FF9
__12F615                          00000001
__DEBUG                           1


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : X---XXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXX-----
MPASM  5.51            SISTEMA_AMOSTRAGEM.ASM   11-20-2021  23:52:01         PAGE 18


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)


2000 : -------X-------- ---------------- ---------------- ----------------

All other memory blocks unused.

Program Memory Words Used:   184
Program Memory Words Free:   840


Errors   :     0
Warnings :    10 reported,     0 suppressed
Messages :     5 reported,     0 suppressed

